// Existing variables
let drawing = false, eraser = false;
let brushColor = '#00ffff', brushSize = 5, brushType = 'pencil';
let lastX = 0, lastY = 0;

// Touch helpers
function getTouchPos(touchEvent) {
    const rect = canvas.getBoundingClientRect();
    return {
        x: touchEvent.touches[0].clientX - rect.left,
        y: touchEvent.touches[0].clientY - rect.top
    };
}

// Start drawing
canvas.addEventListener('mousedown', e => {
    drawing = true;
    lastX = e.offsetX;
    lastY = e.offsetY;
    saveState();
});
canvas.addEventListener('touchstart', e => {
    e.preventDefault(); // prevent scrolling
    drawing = true;
    const pos = getTouchPos(e);
    lastX = pos.x;
    lastY = pos.y;
    saveState();
});

// Stop drawing
canvas.addEventListener('mouseup', () => drawing = false);
canvas.addEventListener('mouseout', () => drawing = false);
canvas.addEventListener('touchend', () => drawing = false);
canvas.addEventListener('touchcancel', () => drawing = false);

// Draw
canvas.addEventListener('mousemove', draw);
canvas.addEventListener('touchmove', e => {
    e.preventDefault(); // prevent scrolling
    const pos = getTouchPos(e);
    draw({offsetX: pos.x, offsetY: pos.y});
});

// Updated draw function (works for both mouse & touch)
function draw(e) {
    if (!drawing) return;

    ctx.lineWidth = brushSize;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    if (eraser) {
        ctx.strokeStyle = '#111';
        ctx.shadowBlur = 0;
    } else {
        ctx.strokeStyle = brushColor;
        if (brushType === 'neon') {
            ctx.shadowColor = brushColor;
            ctx.shadowBlur = 15;
        } else {
            ctx.shadowBlur = 0;
        }
    }

    ctx.beginPath();
    ctx.moveTo(lastX, lastY);
    ctx.lineTo(e.offsetX, e.offsetY);
    ctx.globalAlpha = brushType === 'marker' ? 0.5 : 1.0;
    ctx.stroke();
    lastX = e.offsetX;
    lastY = e.offsetY;
    updateStatus();
}
